/**
 * Export formatters for GeminiCounterPro
 * Generates CSV and Markdown exports from counter data
 */

/**
 * Generate CSV string from daily counts data
 * @param {Object} dailyCounts - { "YYYY-MM-DD": { messages, chats, byModel? } }
 * @param {Object} opts - { total, totalChatsCreated }
 * @returns {string} CSV content
 */
function exportCSV(dailyCounts, opts = {}) {
    const header = 'Date,Messages,Chats,Flash,Thinking,Pro,Weighted';
    const rows = [];

    const sorted = Object.entries(dailyCounts || {}).sort(([a], [b]) => a.localeCompare(b));

    let sumMessages = 0, sumChats = 0, sumFlash = 0, sumThinking = 0, sumPro = 0, sumWeighted = 0;

    for (const [date, entry] of sorted) {
        const messages = entry.messages || 0;
        const chats = entry.chats || 0;
        const bm = entry.byModel || { flash: 0, thinking: 0, pro: 0 };
        const flash = bm.flash || 0;
        const thinking = bm.thinking || 0;
        const pro = bm.pro || 0;
        const weighted = flash * 0 + thinking * 0.33 + pro * 1;
        const weightedStr = weighted % 1 === 0 ? String(weighted) : weighted.toFixed(2);

        rows.push(`${date},${messages},${chats},${flash},${thinking},${pro},${weightedStr}`);

        sumMessages += messages;
        sumChats += chats;
        sumFlash += flash;
        sumThinking += thinking;
        sumPro += pro;
        sumWeighted += weighted;
    }

    // Summary row
    const swStr = sumWeighted % 1 === 0 ? String(sumWeighted) : sumWeighted.toFixed(2);
    rows.push(`TOTAL,${sumMessages},${sumChats},${sumFlash},${sumThinking},${sumPro},${swStr}`);

    return header + '\n' + rows.join('\n') + '\n';
}

/**
 * Generate Markdown report from counter data
 * @param {Object} dailyCounts - { "YYYY-MM-DD": { messages, chats, byModel? } }
 * @param {Object} opts - { user, total, totalChatsCreated, currentStreak, bestStreak }
 * @returns {string} Markdown content
 */
function exportMarkdown(dailyCounts, opts = {}) {
    const now = new Date().toISOString().slice(0, 10);
    const user = opts.user || 'Unknown';
    const lines = [];

    lines.push('# Gemini Usage Report');
    lines.push('');
    lines.push(`**User:** ${user} | **Exported:** ${now}`);
    lines.push('');

    // Summary table
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Total Messages | ${opts.total || 0} |`);
    lines.push(`| Chats Created | ${opts.totalChatsCreated || 0} |`);
    if (opts.currentStreak !== undefined) {
        lines.push(`| Current Streak | ${opts.currentStreak} days |`);
    }
    if (opts.bestStreak !== undefined) {
        lines.push(`| Best Streak | ${opts.bestStreak} days |`);
    }
    lines.push('');

    // Daily breakdown (last 30 days)
    const sorted = Object.entries(dailyCounts || {}).sort(([a], [b]) => a.localeCompare(b));
    const last30 = sorted.slice(-30);

    if (last30.length > 0) {
        lines.push('## Daily Breakdown (Last 30 Days)');
        lines.push('');
        lines.push('| Date | Messages | Flash | Thinking | Pro | Weighted |');
        lines.push('|------|----------|-------|----------|-----|----------|');

        for (const [date, entry] of last30) {
            const messages = entry.messages || 0;
            const bm = entry.byModel || { flash: 0, thinking: 0, pro: 0 };
            const flash = bm.flash || 0;
            const thinking = bm.thinking || 0;
            const pro = bm.pro || 0;
            const weighted = flash * 0 + thinking * 0.33 + pro * 1;
            const wStr = weighted % 1 === 0 ? String(weighted) : weighted.toFixed(1);
            lines.push(`| ${date} | ${messages} | ${flash} | ${thinking} | ${pro} | ${wStr} |`);
        }
        lines.push('');
    }

    lines.push('---');
    lines.push('');
    lines.push('*Generated by Gemini Counter Pro*');
    lines.push('');

    return lines.join('\n');
}

module.exports = { exportCSV, exportMarkdown };
